<!DOCTYPE html>
<!-- starter code from: http://bl.ocks.org/mdml/7537455 -->
<meta charset="utf-8">
<style>
    .node {
        font: 14px Arial;
    }

    @keyframes pulse {
        0% {
            stroke-width: 1px;
        }

        50% {
            stroke-width: 10px;
        }

        100% {
            stroke-width: 1px;
        }
    }

    .pulse {
        stroke: yellow;
        animation: pulse 0.5s linear infinite;
    }

    div {
        background-color: grey;
        color: white;
        font-family: Arial;
        padding: 25px;
        font: 18px;
    }

    span {
        padding-left: 10px;
        padding-right: 10px;
    }

    button {
        border-radius: 5px;
        padding: 5px;
        margin-top: 5px;
    }

    circle {
        cursor: help
    }

    .decide1 {
        stroke: blue;
    }

    .decide0 {
        stroke: red;
    }
</style>

<body>
    <div>
        <span>Select Tree</span>
        <select id='tree_select'></select><span id='results'></span>
        <br><br>
        <span>Highlight Feature Nodes</span>
        <select id='feature_select'></select>
        <br>
    </div>
    <div id=''>
        <svg id='main_vis'></svg>
    </div>

    <script src="http://d3js.org/d3.v4.min.js"></script>
    <script>
        var width = window.innerWidth ||
            document.documentElement.clientWidth ||
            document.body.clientWidth;
        height = (window.innerHeight ||
            document.documentElement.clientHeight ||
            document.body.clientHeight);

        var tree_layout = d3.cluster()
            .size([width - 100, height - 100])
            .separation(function (a, b) {
                return a.parent == b.parent ? 1 : 1;
            });

        var svg = d3.select("#main_vis")
            .attr("width", width)
            .attr("height", height)
            .append("g")
            .attr("transform", "translate(" + (width - 50).toString() + ",75), rotate(90)");

        var random_forest, nodes, links, val_data, tree_data, val_classes;

        var tree_select = d3.select("#tree_select");
        var feature_select = d3.select("#feature_select");

        var colorScale = d3.scaleLinear().domain([0, 1]).range(["crimson", "mediumblue"]);
        var radiusScale = d3.scaleSqrt().domain([1, 40000]).range([1, 10]);

        var tooltip = d3.select("body").append("div")
            .attr("id", "tooltip")
            .style("background", "gray")
            .style("padding", "6px")
            .style("opacity", 0)
            .style("position", "absolute");

        var current_tree = 0;

        function preprocess(node) {
            if (node.children) {
                var child_left = preprocess(node.children[0]),
                    child_right = preprocess(node.children[1]);
                node.children = [child_left, child_right];
                node.leaf_labels = {
                    0: child_left.leaf_labels[0] + child_right.leaf_labels[0],
                    1: child_left.leaf_labels[1] + child_right.leaf_labels[1]
                }
                node.label = `${node.leaf_labels[0]} of 0, ${node.leaf_labels[1]} of 1`;
                return node;
            } else {
                node.label = node.name;
                return node;
            }
        }

        function drawTree(n) {
            console.log("drawing tree " + n.toString());

            nodes = tree_data[n]["nodes"];
            links = tree_data[n]["links"];

            var link = svg.selectAll(".link")
                .data(links)
                .enter().append("path")
                .attr("class", "link")
                .attr("fill", "none")
                .attr("stroke", "silver")
                .attr("stroke-width", "1.5px")
                .attr("d", function (d) {
                    return `M${d.y},${d.x}C${d.parent.y},${d.x} ${d.parent.y},${d.parent.x} ${d.parent.y},${d.parent.x}`;
                });

            var node = svg.selectAll(".node")
                .data(nodes)
                .enter().append("g")
                .attr("class", "node")
                .attr("transform", function (d) {
                    return "translate(" + d.y + "," + d.x + "),rotate(-90)";
                });

            node.append("circle")
                .attr("r", function (d) {
                    return d.children ? 5 * radiusScale(d.data.leaf_labels[1] + d.data.leaf_labels[0]) : 12;
                })
                .attr("fill", function (d) {
                    return colorScale(d.data.leaf_labels[1] / (d.data.leaf_labels[0] + d.data.leaf_labels[1]));
                })
                .attr("stroke", "silver")
                .attr("stroke-width", "1px")
                .attr("class", function (d) {
                    if (d.children) {
                        return "dec_node " + d.data.feature;
                    } else {
                        return "leaf " + (d.data.leaf_labels[0] < d.data.leaf_labels[1] ? "decide1" : "decide0");
                    }
                })
                .on("mousemove", function (d) {
                    //draw tooltip and line
                    tooltip.style("opacity", 0.9)
                        .style("left", `${d3.event.pageX + 20}px`)
                        .style("top", `${d3.event.pageY - 20}px`)
                        .html(d.data.label);
                })
                .on("mouseout", function () {
                    //hide tooltip and line
                    tooltip.style("opacity", 0);
                });

            node.append("text")
                .attr("dx", 0)
                .attr("dy", function (d) {
                    return d.depth < 4 ? -20 : (d.parent.children[0].data.name == d.data.name ? -20 : 25);
                })
                .attr("fill", function (d) {
                    if (d.children) {
                        return "white";
                    } else {
                        return (d.data.leaf_labels[0] < d.data.leaf_labels[1] ? "lightskyblue" : "lightsalmon");
                    }
                })
                .style("text-anchor", "middle")
                .style("pointer-events", "none")
                .text(function (d) {
                    if (d.children) {
                        var th = d.data.threshold.toString();
                        if (th.length > 4) {
                            th = th.slice(0, 4)
                        }
                        return d.data.feature + " > " + th;
                    } else {
                        return "";
                        //return d.data.name;
                    }
                })
                .on("mousemove", function (d) {
                    //draw tooltip and line
                    tooltip.style("opacity", 0.9)
                        .style("left", `${d3.event.pageX + 20}px`)
                        .style("top", `${d3.event.pageY - 20}px`)
                        .html(d.data.label);
                })
                .on("mouseout", function () {
                    //hide tooltip and line
                    tooltip.style("opacity", 0);
                });;
            link.exit().remove();
            node.exit().remove();

            //update classification scores and pulsing nodes
            display_classifications(n);
            feature_highlight();
        }


        d3.queue()
            .defer(d3.csv, "test_val_dump.csv")
            .defer(d3.json, "test_rf_dump.json")
            .await(function (error, data, trees) {
                random_forest = trees;
                val_data = data;

                console.log({
                    "forest": random_forest,
                    "data": data
                });

                tree_data = random_forest["rules"].map(function (r) {
                    var dec_tree = preprocess(r);
                    var root = d3.hierarchy(dec_tree);
                    tree_layout(root);
                    nodes = root.descendants();
                    links = root.descendants().slice(1);
                    nodes.forEach(function (d, i) {
                        d.data.id = i.toString();
                    });
                    return {
                        "nodes": nodes,
                        "links": links
                    };
                });

                val_classes = tree_data.map(function(t){
                    return get_classifications(t.nodes);
                });

                //set up selection
                tree_select.on('change', function () {
                    svg.selectAll("*").remove();
                    drawTree(Number(tree_select.property('value')));
                });

                feature_select.on('change', feature_highlight);

                tree_options = tree_select.selectAll("option").data(Array.from(Array(random_forest.trees.length).keys()))
                    .enter().append('option').text(function (d) {
                        return d;
                    });
                
                var ft_names = random_forest.feature_names;
                ft_names.unshift("None");

                feature_options = feature_select.selectAll("option").data(ft_names)
                    .enter().append('option').text(function (d) {
                        return d;
                    });

                //visualize the first tree only for now
                drawTree(0);

            });

            function feature_highlight() {
                var feat = feature_select.property('value');
                d3.selectAll(".dec_node").classed("pulse", false);
                if (feat !== "None"){
                    d3.selectAll("." + feat).classed("pulse", true);
                }
            }

        function display_classifications(n) {
            d3.select("#results").text(`Validation Accuracy: ${val_classes[n].score}`);
        }

        function get_classifications(nodes) {
            var classifications = val_data.map(function (d) {
                return classify(d, Number(d['label']), nodes);
            });
            var score = classifications.filter(function (d) {
                return d.label === d.pred;
            }).length / classifications.length;
            return {
                "classes": classifications,
                "score": score
            };
            //console.log("classification results", result);
        }

        //return classification, actual label, path
        function classify(x, y, nodes) {
            //console.log(x);
            var class_data = traverse(x, nodes, 0, []);
            class_data["label"] = y;
            //console.log(class_data);
            return class_data;
        }

        function traverse(data, nodes, current, path) {
            var curr_node = nodes[current].data;
            path.push(curr_node.id);
            if (!curr_node.children) {
                return {
                    "path": path,
                    "leaf_id": curr_node.id,
                    "pred": (curr_node.leaf_labels[0] > curr_node.leaf_labels[1] ? 0 : 1)
                };
            } else if (Number(data[curr_node.feature]) > curr_node.threshold) {
                return traverse(data, nodes, Number(curr_node.children[0].id), path);
            } else {
                return traverse(data, nodes, Number(curr_node.children[1].id), path);
            }
        }

        d3.select(self.frameElement).style("height", height + "px");
    </script>
</body>